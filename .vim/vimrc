if !1 | finish | endif

"Encoding
set fileencodings=utf-8,sjis
set encoding=utf-8

scriptencoding utf-8

if &compatible
    set nocompatible
endif

"Default plugin disable
let g:loaded_zip = 1
let g:loaded_zipPlugin = 1
let g:loaded_tar = 1
let g:loaded_tarPlugin = 1
let g:loaded_gzip = 1
let g:loaded_getscript = 1
let g:loaded_getscriptPlugin = 1
let g:loaded_vimball = 1
let g:loaded_vimballPlugin = 1
let g:loaded_2html_plugin = 1
let g:skip_loading_mswin = 1

let g:mapleader = "\<Space>"

"if has('nvim')
"    let s:vimfiles_dir = stdpath("config")
"    let s:vimdata_dir = stdpath("data")
if has('win32')
    let s:vimfiles_dir = expand('~/vimfiles')
    let s:vimdata_dir = expand('~/vimfiles')
else
    let s:vimfiles_dir = expand('~/.vim')
    let s:vimdata_dir = expand('~/.vim')
endif
let s:swap_dir = s:vimfiles_dir . '/swap'
let s:undo_dir = s:vimfiles_dir . '/undo'

"Function
function! ShowModified() abort
    if &modified && &filetype !=# "help" && &buftype !=# "terminal"
        return " %m" 
    else
        return ""
    endif
endfunction

function! s:ToggleQuickfix() abort
    let l:nr = winnr('$')
    let l:loc = !empty(getloclist(0))
    if l:loc
        topleft lwindow
    else
        topleft cwindow
    endif
    let l:nr2 = winnr('$')
    if l:nr == l:nr2
        if l:loc
            lclose
        else
            cclose
        endif
    endif
endfunction

function! s:EditActualFile(filename) abort
    let l:actualFilename = resolve(expand(a:filename))
    execute "e " . l:actualFilename
endfunction

function! s:MakeDir(dir) abort
    if !isdirectory(a:dir)
        call mkdir(a:dir, 'p')
    endif
endfunction

function! s:AdjustWindowHeight(minHeight, maxHeight) abort
    execute max([min([line("$"), a:maxHeight]), a:minHeight]) . "wincmd _"
endfunction

function! s:QuickfixSettings() abort
    setlocal nowrap
    call s:AdjustWindowHeight(3,8)
endfunction

function! s:GrepSettings() abort
    setlocal wildignore+=*/node_modules/*
    setlocal wildignore+=*/.git/*
endfunction

function! s:WebAppsSettings() abort
    setlocal tabstop=2
    setlocal shiftwidth=2
    setlocal iskeyword+=-
endfunction

call s:MakeDir(s:undo_dir)
call s:MakeDir(s:swap_dir)

"Command
command Cd execute 'lcd %:h'

"Options (:options)
"2 moving around, searching and patterns
set wrapscan
set incsearch
set ignorecase
set smartcase
"4 displaying text
set scrolloff=5
set breakindent
set showbreak=>\
set display=lastline
set cmdheight=2
set list
set listchars=tab:^-
set number
"5 syntax, highlighting and spelling
set background=dark
set hlsearch
set termguicolors
set cursorline
"6 multiple windows
set laststatus=2
set statusline=%<%f%m%r%h%w%=
set statusline+=\|\ %{&fileencoding},%{&fileformat}\ \|
set statusline+=\ %Y\ \|\ %2l/%L,%-2c\ \|
set hidden
"8 terminal
set title
set titlestring=%F
"12 messages and info
set showcmd
set noerrorbells
set visualbell t_vb=
set belloff=all
"13 selecting text
set clipboard+=unnamed
"14 editing text
set undofile
execute 'set undodir=' . s:undo_dir
set backspace=indent,eol,start
set pumheight=5
set showmatch
set matchtime=1
"15 tabs and indenting
set tabstop=4
set shiftwidth=4
set expandtab
set autoindent
set smartindent
"19 reading and writing files
set nobackup
"20 the swap file
execute 'set directory=' . s:swap_dir
set swapfile
"21 command line editing
set wildmode=longest,full
set wildmenu
"27 various
set viminfo='50,<500,s100,h
execute 'set viminfo+=n' . escape(s:vimfiles_dir, '\') . '/.viminfo'

colorscheme desert

"Mapping
nnoremap <Space> <Nop>
nnoremap <Leader>w :<C-u>write<CR>
nnoremap <Leader>q :<C-u>quit<CR>
nnoremap <Leader>m :<C-u>marks<CR>
nnoremap <Leader>rg :<C-u>registers<CR>
nnoremap <Leader>gs :<C-u>s///g<Left><Left><Left>
nnoremap <Leader>gps :<C-u>%s///g<Left><Left><Left>
nnoremap <Leader>s. :<C-u>source $MYVIMRC<CR>
nnoremap <Leader>d :<C-u>%s/\s\+$//e<CR>
nnoremap <Leader>tj :<C-u>tag<CR>
nnoremap <Leader>tk :<C-u>pop<CR>
nnoremap <Leader>tl :<C-u>tags<CR>
nnoremap <Leader>tm <C-w>T
nnoremap <silent> <Leader><C-l> :<C-u>nohlsearch<CR><C-l>
"http://deris.hatenablog.jp/entry/20130404/1365086716
nnoremap <silent> <Leader>o :<C-u>for i in range(1, v:count1) \| call append(line('.'),   '') \| endfor \| silent! call repeat#set("<Leader>o", v:count1)<CR>
nnoremap <silent> <Leader>O :<C-u>for i in range(1, v:count1) \| call append(line('.')-1, '') \| endfor \| silent! call repeat#set("<Leader>O", v:count1)<CR>
nnoremap <silent> <Leader>. :<C-u>call <SID>EditActualFile($MYVIMRC)<CR>
nnoremap <silent> <Leader>g. :<C-u>call <SID>EditActualFile($MYGVIMRC)<CR>
nnoremap <silent> <Down> <C-w>-
nnoremap <silent> <Up> <C-w>+
nnoremap <silent> <Left> <C-w><
nnoremap <silent> <Right> <C-w>>
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
nnoremap Y y$
nnoremap <C-]> g<C-]>
nnoremap Q @q
nnoremap <expr> [c !empty(getloclist(0)) ? ":<C-u>lprevious<CR>" : ":<C-u>cprevious<CR>"
nnoremap <expr> ]c !empty(getloclist(0)) ? ":<C-u>lnext<CR>" : ":<C-u>cnext<CR>"
nnoremap co :<C-u>call <SID>ToggleQuickfix()<CR>
noremap <Leader>h ^
noremap <Leader>l $
noremap j gj
noremap k gk
noremap gj j
noremap gk k
noremap : ;
noremap ; :
noremap x "_x
noremap X "_X
noremap * *N
inoremap jj <Esc>
inoremap <C-c> <Esc>
inoremap <S-Tab> <C-d>
inoremap <C-@> <C-[>
inoremap <C-U> <C-G>u<C-U>
cnoremap <C-q> <C-f>
cnoremap <C-b> <Left>
cnoremap <C-f> <Right>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <C-d> <Del>
tnoremap jj <C-\><C-n>

"Autocmd
augroup myAutocmd
    autocmd!
    autocmd ColorScheme * highlight clear Cursorline
    autocmd InsertLeave * set nopaste
    autocmd BufReadPost * if line("'\"") >= 1 &&
                \ line("'\"") <= line("$") && &ft !~# 'commit' |
                \ exe "normal! g`\"" | endif

    autocmd FileType help,vim setlocal keywordprg=:help
    autocmd FileType help,qf nnoremap <silent> <buffer> q :<C-u>q<CR>
    autocmd FileType qf call s:QuickfixSettings()
    autocmd FileType html,pug,css,scss,javascript,typescript,vue
                \ call s:WebAppsSettings()

    autocmd QuickFixCmdPre *grep* call s:GrepSettings()
    autocmd QuickFixCmdPost *grep* setlocal wildignore&
    autocmd QuickFixCmdPost *grep*,make if len(getqflist()) != 0 | topleft cwindow | endif
augroup END

"if has('nvim')
"else
if has('win32')
    let $PATH = s:vimfiles_dir . '\tool;' . $PATH
    nnoremap <silent> <Leader>to :<C-u>botright terminal powershell<CR>
    tnoremap <silent> <C-w>t <C-w>:<C-u>vertical terminal powershell<CR>
else
    set shell=/bin/bash
    nnoremap <silent> <Leader>to :<C-u>botright terminal<CR>
    tnoremap <silent> <C-w>t <C-w>:<C-u>vertical terminal<CR>
endif

function! s:TerminalmodeSettings() abort
    setlocal nonumber
    setlocal winfixheight
    nnoremap <silent> <buffer> <Leader>q :<C-u>bdelete!<CR>
    tnoremap <silent> <buffer> <C-w>q <C-w>:<C-u>bdelete!<CR>
    tnoremap <silent> <buffer> <C-w>; <C-w>:
endfunction

set termwinsize=8x0

augroup vimAutocmd
    autocmd BufEnter * if (winnr('$') == 1 &&
                \ (&buftype ==# 'terminal' || &filetype ==# 'qf')) | q! | endif
    autocmd TerminalWinOpen * if &buftype ==# 'terminal' |
                \ call s:TerminalmodeSettings() | endif
augroup END

if executable('rg')
    set grepprg=rg\ --vimgrep\ --hidden
    set grepformat=%f:%l:%c:%m
endif

"Finish when using git commit
if $HOME != $USERPROFILE && $GIT_EXEC_PATH != ''
    syntax enable
    finish
end

packadd! matchit

"Plugin
"vim-plug
if empty(globpath(&rtp, 'autoload/plug.vim'))
    filetype plugin indent on
    syntax enable
    finish
endif

let s:plug_dir = s:vimdata_dir . '/plugged'
call plug#begin(s:plug_dir)
"Manual
Plug 'junegunn/vim-plug'
Plug 'vim-jp/vimdoc-ja'
"vim-lsp, auto complete, snippet
Plug 'prabirshrestha/vim-lsp'
Plug 'mattn/vim-lsp-settings'
Plug 'prabirshrestha/asyncomplete.vim'
Plug 'prabirshrestha/asyncomplete-lsp.vim'
Plug 'hrsh7th/vim-vsnip'
Plug 'hrsh7th/vim-vsnip-integ'
"fuzzy finder
Plug 'ctrlpvim/ctrlp.vim'
Plug 'mattn/ctrlp-matchfuzzy'
"Git
Plug 'airblade/vim-gitgutter'
Plug 'tpope/vim-fugitive'
"Filer
Plug 'mattn/vim-molder'
Plug 'mattn/vim-molder-operations'
Plug 'lambdalisue/fern.vim', { 'on': 'Fern' }
Plug 'lambdalisue/fern-git-status.vim', { 'on': 'Fern' }
"Language
Plug 'prabirshrestha/asyncomplete-emmet.vim', { 'for': 'html' }
Plug 'mattn/emmet-vim', { 'for': 'html' }
Plug 'alvan/closetag.vim', { 'for': 'html' }
Plug 'digitaltoad/vim-pug', { 'for': 'pug' }
Plug 'dNitro/vim-pug-complete', { 'for': 'pug' }
Plug 'yami-beta/asyncomplete-omni.vim', { 'for': 'pug' }
Plug 'posva/vim-vue', { 'for': 'vue' }
"Others
Plug 'tpope/vim-surround'
Plug 'tpope/vim-repeat'
Plug 'thinca/vim-quickrun'
Plug 'jiangmiao/auto-pairs'
Plug 'kana/vim-operator-user'
Plug 'kana/vim-operator-replace'
Plug 'previm/previm'
Plug 'tyru/open-browser.vim'
"Theme, highlight
Plug 'itchyny/lightline.vim'
Plug 'cocopon/iceberg.vim'
Plug 'gko/vim-coloresque'
call plug#end()

let s:plug = { 'plugs': get(g:, 'plugs', {}) }
function! s:plug.isInstalled(name) abort
    return has_key(self.plugs, a:name) ? isdirectory(self.plugs[a:name].dir) : 0
endfunction

"vimdoc-ja
let s:is_helplang_ja = 0

set helplang=en,ja

function! s:HelplangToggle() abort
    if s:is_helplang_ja
        set helplang=en,ja
        let s:is_helplang_ja = 0
        echo "Help language is English"
    else
        set helplang=ja,en
        let s:is_helplang_ja = 1
        echo "Help language is Japanese"
    endif
endfunction

nnoremap <silent> <Leader>jh :<C-u>call <SID>HelplangToggle()<CR>

"asyncomplete.vim
inoremap <expr> <Tab> pumvisible() ? "\<Down>" : "\<Tab>"
inoremap <expr> <S-Tab> pumvisible() ? "\<Up>" : "\<C-d>"
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<CR>"

augroup asyncompleteAutocmd
    autocmd!
    autocmd CompleteDone * if pumvisible() == 0 | pclose | endif
    autocmd User asyncomplete_setup call asyncomplete#register_source(
                \ asyncomplete#sources#emmet#get_source_options({
                    \ 'name': 'emmet',
                    \ 'whitelist': ['html'],
                    \ 'completor': function('asyncomplete#sources#emmet#completor'),
                \ }))
    autocmd User asyncomplete_setup call asyncomplete#register_source(
                \ asyncomplete#sources#emmet#get_source_options({
                    \ 'name': 'omni',
                    \ 'whitelist': ['pug'],
                    \ 'completor': function('asyncomplete#sources#omni#completor'),
                    \ 'config': {
                        \ 'show_source_kind': 1,
                    \ },
                \ }))
augroup END

"vim-lsp, vim-lsp-settings
let g:lsp_use_lua = has('nvim-0.4.0') || (has('lua') && has('patch-8.2.0775'))
let g:lsp_diagnostics_enabled = 1
let g:lsp_diagnostics_float_cursor = 1
let g:lsp_diagnostics_float_delay = 200
let g:lsp_diagnostics_signs_enabled = 1
let g:lsp_diagnostics_signs_priority = 11
let g:lsp_format_sync_timeout = 1000
let g:lsp_settings =  {
            \ 'efm-langserver': {
                \ 'disabled': v:false,
                \ 'allowlist': [  'pug', 'javascript', 'typescript', 'vue' ]
                \ }
            \ }
let g:lsp_settings_filetype_vue = ['vls', 'efm-langserver']
let g:lsp_settings_enable_suggestions = 0

function! s:VimlspSettings() abort
    setlocal omnifunc=lsp#complete
    setlocal signcolumn=yes
    if exists('+tagfunc') | setlocal tagfunc=lsp#tagfunc | endif
    nmap <buffer> gd <plug>(lsp-definition)
    nmap <buffer> <Leader>rn <plug>(lsp-rename)
    nmap <buffer> [g <plug>(lsp-previous-diagnostic)
    nmap <buffer> ]g <plug>(lsp-next-diagnostic)
    if &filetype != "vim" | nmap <buffer> K <plug>(lsp-hover) | endif
    inoremap <buffer> <expr> <C-f> lsp#scroll(+4)
    inoremap <buffer> <expr> <C-b> lsp#scroll(-4)
endfunction

augroup vimlspAutocmd
    autocmd!
    autocmd User lsp_buffer_enabled call s:VimlspSettings()
augroup END

"vim-vsnip
imap <expr> <C-j> vsnip#expandable() ? '<Plug>(vsnip-expand)' : '<C-j>'
imap <expr> <C-l> vsnip#available(1) ? '<Plug>(vsnip-expand-or-jump)' : '<C-l>'

"CtrlP
let g:ctrlp_match_window = 'min:8,max:8'
let g:ctrlp_cache_dir = s:vimfiles_dir . '/cache/ctrlp'
let g:ctrlp_custom_ignore = {
            \ 'dir':  '\v([\/]\.(git|hg|svn))|node_modules$',
            \ 'file': '\v\.(exe|so|dll)$',
            \ }
let g:ctrlp_match_func = {'match': 'ctrlp_matchfuzzy#matcher'}

"vim-gitgutter
let g:gitgutter_map_keys = 0

"vim-molder
let g:loaded_netrw = 1
let g:loaded_netrwPlugin = 1
let g:loaded_netrwSettings = 1
let g:loaded_netrwFileHandlers = 1
let g:molder_show_hidden = 1

function! s:VimmolderSettings() abort
    nmap <buffer> l <Plug>(molder-open)
    nmap <buffer> h <Plug>(molder-up)
    nmap <buffer> . <Plug>(molder-toggle-hidden)
    nnoremap <buffer> e :<C-u>lcd %<CR>:e<Space>
    nnoremap <buffer> cd :<C-u>lcd %<CR>
endfunction

augroup vimmolderAutocmd
    autocmd!
    autocmd FileType molder call s:VimmolderSettings()
augroup END

"fern
function! s:FernSettings()
    setlocal nonumber
    nmap <buffer> <Leader>. <Plug>(fern-action-hidden)
endfunction

nnoremap <silent> <Leader>f :<C-u>Fern . -reveal=% -drawer -stay -toggle<CR>

augroup fernAutocmd
    autocmd!
    autocmd FileType fern call s:FernSettings()
augroup END

"lightline.vim
let g:ctrlp_status_func = {
            \ 'main': 'CtrlPStatusFunc1',
            \ 'prog': 'CtrlPStatusFunc2',
            \ }

let g:lightline = {
            \ 'colorscheme': 'iceberg',
            \ 'active': {
                \ 'left' : [ ['mode', 'paste'],
                \            ['fugitive', 'readonly', 'filename'], ['ctrlpmark'] ],
                \ 'right': [ ['lsp_errors', 'lsp_warnings', 'lineinfo'],
                \            ['filetype'],
                \            ['fileencoding_and_fileformat'] ],
                \ },
            \ 'inactive': {
                \ 'right': [ ['lineinfo'] ],
                \ },
            \ 'component': {
                \ 'filename': '%f%{%ShowModified()%}',
                \ 'lineinfo': '%2l/%L,%-2c%<',
                \ 'filetype': '%{&filetype !=# "" ? &filetype : ""}',
                \ },
            \ 'component_function': {
                \ 'mode': 'LightlineMode',
                \ 'fugitive': 'LightlineFugitive',
                \ 'fileencoding_and_fileformat': 'LightlineEncAndFt',
                \ 'ctrlpmark': 'CtrlPMark',
                \ },
            \ 'component_expand': {
                \ 'lsp_errors': 'LightlineLSPErrors',
                \ 'lsp_warnings': 'LightlineLSPWarnings',
                \ },
            \ 'component_type': {
                \ 'lsp_errors': 'error',
                \ 'lsp_warnings': 'warning',
                \ },
            \ }

function! LightlineMode() abort
    return &filetype ==# "help" ? "HELP" :
                \ &filetype ==# "qf" ? "" :
                \ &filetype ==# "ctrlp" ? "" :
                \ &filetype ==# "molder" ? "MOLDER" :
                \ winwidth(0) <= 70 ? "" :
                \ lightline#mode()
endfunction

function! LightlineFugitive() abort
    if winwidth(0) > 70 && &filetype !~# '\v(help|qf|ctrlp|quickrun)' && &buftype !=# "terminal"
        if exists('*FugitiveHead')
            let l:branch = FugitiveHead()
            return branch !=# "" ? " ". l:branch : ""
        endif
    endif
    return ""
endfunction

function! LightlineEncAndFt() abort
    if winwidth(0) > 70 && &buftype !=# "terminal"
        let l:encoding = &fileencoding !=# "" ? &fileencoding : &encoding
        let l:format = &fileformat
        return l:encoding . " " . l:format
    endif
    return ""
endfunction

function! LightlineLSPWarnings() abort
    let l:counts = lsp#get_buffer_diagnostics_counts()
    return l:counts.warning == 0 ? '' : printf('W:%d', l:counts.warning)
endfunction

function! LightlineLSPErrors() abort
    let l:counts = lsp#get_buffer_diagnostics_counts()
    return l:counts.error == 0 ? '' : printf('E:%d', l:counts.error)
endfunction

function! CtrlPMark()
    if &filetype ==# 'ctrlp' && has_key(g:lightline, 'ctrlp_item')
        call lightline#link('cR'[g:lightline.ctrlp_regex])
        return g:lightline.ctrlp_item
    else
        return ''
    endif
endfunction

function! CtrlPStatusFunc1(focus, byfname, regex, prev, item, next, marked)
    let g:lightline.ctrlp_regex = a:regex
    let g:lightline.ctrlp_item = a:item
    return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc2(str)
    return lightline#statusline(0)
endfunction

set noshowmode

augroup lightlineAutocmd
    autocmd!
    autocmd User lsp_diagnostics_updated call lightline#update()
augroup END

"vim-vue
let g:vue_pre_processors = ['pug', 'typescript', 'scss']

"quickrun
let g:quickrun_config = {
            \ '_': {
                \ 'outputter': 'buffer',
                \ 'outputter/buffer/name': "[Quickrun Output]",
                \ 'outputter/buffer/split': ":botright 8",
                \ 'outputter/buffer/running_mark': "[Runninng...]",
                \ 'runner': 'job',
                \ },
                \ 'tex' : {
                    \ 'command': 'lualatex',
                    \ 'exec': ['%c -interaction=nonstopmode -file-line-error %s']
                    \ },
                \ 'scss' : {
                    \ 'command': 'sass',
                    \ 'exec': ['%c %s:%s.css']
                    \ }
                \ }

nmap <Leader>rq <Plug>(quickrun)

augroup quickrunAutocmd
    autocmd!
    autocmd BufEnter * if (winnr('$') == 1 && &filetype ==# 'quickrun') | q! | endif
augroup END

"auto-pairs
nnoremap <Leader>( :<C-u>call AutoPairsToggle()<CR>
augroup autoPairsAutocmd
    autocmd!
    autocmd Filetype pug let b:autopairs_enabled = 0
augroup END

"vim-operator-replace
map _ <Plug>(operator-replace)

"open-browser
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)

"Colorscheme
if s:plug.isInstalled("iceberg.vim")
    colorscheme iceberg
endif

augroup delayAutocmd
    autocmd!
    autocmd Filetype * set formatoptions-=ro
augroup END
